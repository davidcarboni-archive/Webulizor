package net.jirasystems.webulizor.framework;

import java.io.IOException;
import java.net.URL;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import net.jirasystems.webulizor.annotations.DatabaseConnection;
import net.jirasystems.webulizor.annotations.ExceptionAction;
import net.jirasystems.webulizor.annotations.HomeAction;
import net.jirasystems.webulizor.annotations.NotFoundAction;
import net.jirasystems.webulizor.annotations.Route;
import net.jirasystems.webulizor.helpers.Database;
import net.jirasystems.webulizor.helpers.ForwardedRequest;
import net.jirasystems.webulizor.helpers.Path;
import net.jirasystems.webulizor.helpers.Velocity;
import net.jirasystems.webulizor.interfaces.Action;
import net.jirasystems.webulizor.interfaces.ExceptionAware;
import net.jirasystems.webulizor.interfaces.Get;
import net.jirasystems.webulizor.interfaces.NotFoundAware;
import net.jirasystems.webulizor.interfaces.Post;
import net.jirasystems.webulizor.metrics.UserJourney;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.apache.http.HttpStatus;
import org.reflections.Reflections;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;

/**
 * This is the framework controller.
 * 
 * @author David Carboni
 * 
 */
public class App extends HttpServlet {

	/**
	 * Generated by Eclipse.
	 */
	private static final long serialVersionUID = -8124528033609567276L;

	private Map<String, Class<? extends Action>> get = new HashMap<String, Class<? extends Action>>();
	private Map<String, Class<? extends Action>> post = new HashMap<String, Class<? extends Action>>();

	private Class<? extends Action> homeAction;
	private Class<? extends Action> exceptionAction;
	private Class<? extends Action> notFoundAction;

	@Override
	public void init() throws ServletException {

		// Set up reflections:
		ServletContext servletContext = getServletContext();
		Set<URL> urls = new HashSet<URL>(
				ClasspathHelper.forWebInfLib(servletContext));
		urls.add(ClasspathHelper.forWebInfClasses(servletContext));
		Reflections reflections = new Reflections(
				new ConfigurationBuilder().setUrls(urls));

		// Get annotated classes:
		Set<Class<? extends Action>> actionClasses = reflections
				.getSubTypesOf(Action.class);

		// Configure the classes:
		for (Class<? extends Action> actionClass : actionClasses) {

			// Check the action for its possible uses.
			// NB error and not found actions need
			// not necessarily be routable:
			setRoute(actionClass);
			setHomeAction(actionClass);
			setErrorAction(actionClass);
			setNotFoundAction(actionClass);
		}
		log("Found " + get.size() + " GET actions.");
		log("Found " + post.size() + " POST actions.");

		// Attempt to use WEB-INF as a log location.
		// If we're running from a WAR this will be null and no Velocity log
		// will be generated. TODO: Allow a log path to be set from .properties
		String webInfPath = servletContext.getRealPath("WEB-INF");
		Velocity.initialise(webInfPath);
	}

	/**
	 * Determines if the given class is routable via one of the supported HTTP
	 * methods.
	 * 
	 * @param actionClass
	 *            The class to inspect.
	 */
	private void setRoute(Class<? extends Action> actionClass) {

		if (actionClass.getAnnotation(Route.class) != null) {

			if (Get.class.isAssignableFrom(actionClass)) {
				get.put(Path.getPath(actionClass), actionClass);
			}

			if (Post.class.isAssignableFrom(actionClass)) {
				post.put(Path.getPath(actionClass), actionClass);
			}
		}
	}

	/**
	 * Determines if the given {@link Action} class is the {@link HomeAction}
	 * action.
	 * 
	 * @param actionClass
	 *            The class to inspect.
	 * @return If the given class was set as the {@link HomeAction}, true.
	 * @throws ServletException
	 *             If a {@link HomeAction} {@link Action} is already defined.
	 */
	private boolean setHomeAction(Class<? extends Action> actionClass)
			throws ServletException {
		if (actionClass.getAnnotation(HomeAction.class) != null) {
			if (homeAction != null) {
				// Only one home action can be supported:
				throw new ServletException("Could not configure "
						+ HomeAction.class + " as " + actionClass.getName()
						+ " because it is already configured as "
						+ homeAction.getName());
			}
			homeAction = actionClass;
			return true;
		}
		return false;
	}

	/**
	 * Determines if the given {@link Action} class is the
	 * {@link ExceptionAction}.
	 * 
	 * @param actionClass
	 *            The class to inspect.
	 * @return If the given class was set as the {@link ExceptionAction}, true.
	 * @throws ServletException
	 *             If an {@link ExceptionAction} is already defined.
	 */
	private boolean setErrorAction(Class<? extends Action> actionClass)
			throws ServletException {
		if (actionClass.getAnnotation(ExceptionAction.class) != null) {
			if (exceptionAction != null) {
				// Only one error action can be supported:
				throw new ServletException("Could not configure "
						+ ExceptionAction.class + " as "
						+ actionClass.getName()
						+ " because it is already configured as "
						+ exceptionAction.getName());
			}
			exceptionAction = actionClass;
			return true;
		}
		return false;
	}

	/**
	 * Determines if the given {@link Action} class is the
	 * {@link NotFoundAction}.
	 * 
	 * @param actionClass
	 *            The class to inspect.
	 * @return If the given class was set as the {@link NotFoundAction}, true.
	 * @throws ServletException
	 *             If an {@link NotFoundAction} is already defined.
	 */
	private boolean setNotFoundAction(Class<? extends Action> actionClass)
			throws ServletException {
		if (actionClass.getAnnotation(NotFoundAction.class) != null) {
			if (notFoundAction != null) {
				// Only one error action can be supported:
				throw new ServletException("Could not configure "
						+ NotFoundAction.class + " as " + actionClass.getName()
						+ " because it is already configured as "
						+ notFoundAction.getName());
			}
			notFoundAction = actionClass;
			return true;
		}
		return false;
	}

	@Override
	protected void doGet(HttpServletRequest request,
			HttpServletResponse response) throws ServletException {
		try {
			doMethod(this.get, ForwardedRequest.newInstance(request), response);
		} catch (Throwable t) {
			doError(request, response, t);
		}
	}

	@Override
	protected void doPost(HttpServletRequest request,
			HttpServletResponse response) throws ServletException {
		try {
			doMethod(this.post, ForwardedRequest.newInstance(request), response);
		} catch (Throwable t) {
			doError(request, response, t);
		}
	}

	/**
	 * Handles an uncaught exception by calling {@link #exceptionAction}, if
	 * configured.
	 * 
	 * @param t
	 *            {@link Throwable}.
	 * @throws ServletException
	 *             IF {@link #exceptionAction} is not defined.
	 */
	private void doError(HttpServletRequest request,
			HttpServletResponse response, Throwable t) throws ServletException {

		// Default status:
		response.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR);

		if (this.exceptionAction != null) {

			// Set up the error action:
			Action errorAction = instantiate(this.exceptionAction, request);
			if (ExceptionAware.class.isAssignableFrom(this.exceptionAction)) {
				((ExceptionAware) errorAction).setException(t);
			}

			// Try to perform the action:
			try {
				Connection connection = setupConnection(
						request.getRequestURI(), errorAction, null);
				Map<String, Object> context = new HashMap<String, Object>();
				setup(errorAction, request, response, connection, context);
				errorAction.perform();
			} catch (Exception e) {
				throw new ServletException("Unable to process error "
						+ Action.class.getSimpleName(), e);
			}

		} else {

			// If no error action is defined, throw a ServletException:
			throw new ServletException("Error executing "
					+ request.getRequestURI(), t);
		}
	}

	/**
	 * Follows a path of Actions.
	 * 
	 * @param actions
	 *            The map of actions to match to the reqest path.
	 * @param request
	 *            {@link HttpServletRequest}
	 * @param response
	 *            {@link HttpServletResponse}
	 * @throws ServletException
	 *             If an {@link AppException} occurs.
	 * @throws IOException
	 *             If an error occurs in one of the Actions.
	 */
	private void doMethod(Map<String, Class<? extends Action>> actions,
			HttpServletRequest request, HttpServletResponse response)
			throws Throwable {

		// Note the request:
		UserJourney.addRequest(request);

		// Variables for this request path:
		Map<String, Object> context = new HashMap<String, Object>();
		Connection connection = null;

		// Map the request path to an action:
		Action action = mapRequestPath(actions, request);

		// Follow the [path of] Actions:
		try {
			while (action != null) {
				connection = setupConnection(request.getRequestURI(), action,
						connection);
				setup(action, request, response, connection, context);
				action = action.perform();
			}
			commitConnection(connection);
		} catch (Throwable t) {
			rollbackConnection(connection);
			throw t;
		} finally {
			closeConnection(connection);
		}
	}

	/**
	 * Sets up a database connection if the given {@link Action} requires one
	 * (but does not set it in the action - that is done by
	 * {@link #setup(Action, HttpServletRequest, HttpServletResponse, Connection, Map)}
	 * ). This enables the same {@link Connection} to be shared by all actions
	 * in a path if/when any of the actions requires one, and that a transaction
	 * is started only if/when needed.
	 * 
	 * @param action
	 *            The action to be provided with a database {@link Connection}
	 *            if it requires one.
	 * @return The database connection, because the connection passed in may be
	 *         null if no connection has been started yet.
	 * @throws SQLException
	 *             If a database error occurs.
	 */
	private Connection setupConnection(String name, Action action,
			Connection connection) throws SQLException {
		Connection result = connection;

		if (action != null) {
			// Does the current action in the path need a database connection?
			DatabaseConnection databaseConnection = action.getClass()
					.getAnnotation(DatabaseConnection.class);

			// Default to provide a connection, with a transaction:
			boolean required = databaseConnection == null
					|| databaseConnection.required();
			boolean transaction = databaseConnection == null
					|| databaseConnection.transaction();

			if (required) {

				// Get a connection if we haven't already:
				if (result == null) {
					result = Database.getConnection(name);
				}

				// If this action requires a transaction and
				// no other action in the chain has started one
				// then start one now:
				if (transaction && result.getAutoCommit()) {
					result.setAutoCommit(false);
				}
			}
		}

		return result;
	}

	/**
	 * If a {@link Connection} has been created and a transaction in active,
	 * commits the transaction.
	 */
	private void commitConnection(Connection connection) {
		if (connection != null) {
			try {
				if (!connection.getAutoCommit()) {
					connection.commit();
				}
			} catch (SQLException e) {
				System.out.println(ExceptionUtils.getStackTrace(e));
			}
		}
	}

	/**
	 * If a {@link Connection} has been created and a transaction in active,
	 * rolls back the transaction.
	 */
	private void rollbackConnection(Connection connection) {
		if (connection != null) {
			try {
				if (!connection.getAutoCommit()) {
					connection.rollback();
				}
			} catch (SQLException e) {
				System.out.println(ExceptionUtils.getStackTrace(e));
			}
		}
	}

	/**
	 * Closes the {@link Connection} if one has been created.
	 * 
	 */
	private void closeConnection(Connection connection) {
		if (connection != null) {
			try {
				connection.close();
			} catch (SQLException e) {
				System.out.println(ExceptionUtils.getStackTrace(e));
			}
		}
	}

	/**
	 * Sets the {@link HttpServletRequest}, {@link HttpServletResponse} and
	 * {@link ServletContext}.
	 * 
	 * @param action
	 *            The instance to be set up.
	 * @param request
	 *            {@link HttpServletRequest}.
	 * @param response
	 *            {@link HttpServletResponse}.
	 */
	private void setup(Action action, HttpServletRequest request,
			HttpServletResponse response, Connection connection,
			Map<String, Object> context) {
		if (action != null) {
			action.setRequest(request);
			action.setResponse(response);
			action.setServletContext(getServletContext());
			action.setContext(context);

			// Does this action need a database connection?
			// Default is to provide a connection:
			DatabaseConnection databaseConnection = action.getClass()
					.getAnnotation(DatabaseConnection.class);
			boolean required = databaseConnection == null
					|| databaseConnection.required();
			if (required) {
				action.setConnection(connection);
			}

		}
	}

	/**
	 * Locates a {@link Get} or {@link Post} for the request.
	 * 
	 * @param actions
	 *            The map of {@link Get} or {@link Post} actions.
	 * @param request
	 *            The request.
	 * @return An {@link Action} for this request, or null if no match is found.
	 * @throws AppException
	 *             If an error occurs.
	 */
	private Action mapRequestPath(Map<String, Class<? extends Action>> actions,
			HttpServletRequest request) throws AppException {

		// Find a class:
		Class<? extends Action> actionClass = null;
		String actionKey = null;
		if (StringUtils.equals("/", request.getPathInfo())) {
			actionClass = homeAction;
		} else {
			for (Entry<String, Class<? extends Action>> action : actions
					.entrySet()) {
				if (StringUtils.startsWithIgnoreCase(request.getPathInfo(),
						action.getKey())) {
					if (actionClass == null) {
						actionClass = action.getValue();
						actionKey = action.getKey();
					} else {
						// We're looking for the longest match:
						if (action.getKey().length() > actionKey.length()) {
							actionClass = action.getValue();
							actionKey = action.getKey();
						}
					}
				}
			}
		}

		return instantiate(actionClass, request);
	}

	private Action instantiate(Class<? extends Action> actionClass,
			HttpServletRequest request) {

		Class<? extends Action> clazz = actionClass;

		if (clazz == null) {
			// Fall back to notFoundAction:
			clazz = notFoundAction;
		}

		if (clazz == null) {

			// Not found and no notFoundAction configured:
			throw new AppException("Unable to match " + request.getMethod()
					+ " request for " + request.getPathInfo()
					+ " to an action.");

		}

		// Instantiate:
		Action result = null;
		try {
			result = clazz.newInstance();

			if (NotFoundAware.class.isAssignableFrom(clazz)) {
				((NotFoundAware) result).setRequestUri(request.getRequestURI());
			}

		} catch (InstantiationException e) {
			throw new AppException("Unable to instantiate "
					+ clazz.getSimpleName(), e);
		} catch (IllegalAccessException e) {
			throw new AppException("Unable to instantiate "
					+ clazz.getSimpleName(), e);
		} catch (NullPointerException e) {
			throw new AppException("No " + Action.class.getSimpleName()
					+ " found for path " + request.getPathTranslated(), e);
		}
		return result;

	}

}
