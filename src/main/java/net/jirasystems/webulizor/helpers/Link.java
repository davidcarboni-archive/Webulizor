package net.jirasystems.webulizor.helpers;

import java.net.URI;
import java.net.URISyntaxException;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import net.jirasystems.webulizor.framework.AppException;
import net.jirasystems.webulizor.interfaces.Action;

import org.apache.commons.lang.StringUtils;
import org.apache.http.client.utils.URIBuilder;

/**
 * Builds links, with an awareness of whether or not the context path should be
 * included. This makes it easier to deploy an application with a context path
 * behind a web server that uses e.g. URL rewriting to hide the context path.
 * 
 * @author David Carboni
 * 
 */
public class Link {

	/**
	 * If you are deploying your webapp behind Apache and are using rewrite
	 * rules to remove the context path, set this to true. This will cause paths
	 * generated by this class to have no context path prepended.
	 */
	public static boolean DROP_CONTEXT = false;

	private static final String separator = "/";

	// Path information:
	private String contextPath;

	// URL information:
	private int serverPort;
	private boolean secure;

	// URL components:
	private String scheme;
	private String host;

	/**
	 * @param action
	 *            Used to determine the context path and URL information.
	 */
	public Link(ServletContext servletContext, HttpServletRequest request) {

		if (DROP_CONTEXT) {
			// De-contextualise:
			contextPath = StringUtils.EMPTY;
		} else {
			// Use the context path:
			contextPath = servletContext.getContextPath();
		}

		// This fixes ROOT context:
		if (StringUtils.endsWith(contextPath, "/")) {
			contextPath = contextPath.substring(0, contextPath.length() - 1);
		}

		// URL information:
		serverPort = request.getServerPort();
		secure = request.isSecure();

		// URL components:
		scheme = request.getScheme();
		host = request.getServerName();

		// // Do we need to consider X-Forwarded-* headers?
		//
		// String forwardedHost = request.getHeader("X-Forwarded-Host");
		// String forwardedScheme = request.getHeader("X-Forwarded-Proto");
		//
		// if (forwardedHost != null && !StringUtils.equals(forwardedHost,
		// host)) {
		// host = forwardedHost;
		// }
		//
		// if (forwardedScheme != null
		// && !StringUtils.equals(forwardedScheme, scheme)) {
		// scheme = forwardedScheme;
		// // Assume standard https or http ports if it's been forwarded:
		// if (StringUtils.equalsIgnoreCase("https", scheme)) {
		// serverPort = 443;
		// secure = true;
		// } else {
		// serverPort = 80;
		// secure = false;
		// }
		// }
	}

	/**
	 * Generates an asset path, e.g. for a CSS or image file. Allows resources
	 * to be reliably referenced, taking into account whether
	 * {@link #DROP_CONTEXT} is true or false.
	 * 
	 * @param path
	 *            The path within the app context (i.e. excluding context path).
	 * @return An absolute path within this host for the given context-relative
	 *         path.
	 */
	public URI resolve(String path) {
		URIBuilder builder = new URIBuilder();
		String fullPath = contextPath + leadingSlash(path);
		builder.setPath(fullPath);
		try {
			return builder.build();
		} catch (URISyntaxException e) {
			throw new AppException("Unable to build URI for path " + path, e);
		}
	}

	/**
	 * Generates an asset path, e.g. for a CSS or image file. Allows resources
	 * to be reliably referenced, taking into account whether
	 * {@link #DROP_CONTEXT} is true or false.
	 * 
	 * @param path
	 *            The path within the app context (i.e. excluding context path).
	 * @param queryString
	 *            A {@link QueryString} to be included in the result.
	 * @return An absolute path within this host for the given context-relative
	 *         path.
	 */
	public URI resolve(String path, QueryString queryString) {
		URIBuilder builder = new URIBuilder();
		String fullPath = contextPath + leadingSlash(path);
		builder.setPath(fullPath);
		if (queryString != null) {
			builder.setQuery(queryString.toQueryString());
		}
		try {
			return builder.build();
		} catch (URISyntaxException e) {
			throw new AppException("Unable to build URI for path " + path, e);
		}
	}

	/**
	 * Generates a path to an {@link Action}. Allows actions to be reliably
	 * referenced, taking into account whether {@link #DROP_CONTEXT} is true or
	 * false.
	 * 
	 * @param action
	 *            The {@link Action} class to generate a link to.
	 * @return An absolute path to the given {@link Action} within this host.
	 */
	public URI resolve(Class<? extends Action> action) {
		URIBuilder builder = new URIBuilder();
		String fullPath = contextPath + leadingSlash(Path.getPath(action));
		builder.setPath(fullPath);
		try {
			return builder.build();
		} catch (URISyntaxException e) {
			throw new AppException("Unable to build URI for "
					+ Action.class.getSimpleName() + " " + action.getName(), e);
		}
	}

	/**
	 * Generates a path to an {@link Action}. Allows actions to be reliably
	 * referenced, taking into account whether {@link #DROP_CONTEXT} is true or
	 * false.
	 * 
	 * @param action
	 *            The {@link Action} class to generate a link to.
	 * @param queryString
	 *            A {@link QueryString} to be included in the result.
	 * @return An absolute path to the given {@link Action} within this host.
	 */
	public URI resolve(Class<? extends Action> action, QueryString queryString) {
		URIBuilder builder = new URIBuilder();
		String fullPath = contextPath + leadingSlash(Path.getPath(action));
		builder.setPath(fullPath);
		if (queryString != null) {
			builder.setQuery(queryString.toQueryString());
		}
		try {
			return builder.build();
		} catch (URISyntaxException e) {
			throw new AppException("Unable to build URI for "
					+ Action.class.getSimpleName() + " " + action.getName(), e);
		}
	}

	/**
	 * Generates an absolute URL to an {@link Action}. Allows URLs to be
	 * reliably referenced, taking into account whether {@link #DROP_CONTEXT} is
	 * true or false.
	 * 
	 * @param action
	 *            The {@link Action} class to generate a URL for.
	 * @return The URL.
	 */
	public URI url(Class<? extends Action> action) {
		URI path = resolve(action);
		return url().resolve(path);
	}

	/**
	 * Generates an absolute URL to an {@link Action}. Allows URLs to be
	 * reliably referenced, taking into account whether {@link #DROP_CONTEXT} is
	 * true or false.
	 * 
	 * @param action
	 *            The {@link Action} class to generate a URL for.
	 * @param queryString
	 *            A query to be appended to the URL.
	 * @return The URL.
	 */
	public URI url(Class<? extends Action> action, QueryString queryString) {
		URIBuilder builder = new URIBuilder();
		URI path = resolve(action, queryString);
		builder.setPath(path.getPath());
		builder.setQuery(path.getQuery());
		try {
			return url().resolve(builder.build());
		} catch (URISyntaxException e) {
			throw new AppException("Error building URL: path=" + path
					+ ", query=" + queryString.toQueryString(), e);
		}
	}

	/**
	 * @return The absolute URL of the application.
	 */
	public URI url() {

		int port;
		if ((!secure && serverPort == 80) || (secure && serverPort == 443)) {
			port = -1;
		} else {
			port = serverPort;
		}
		String userInfo = null;
		String path;
		if (DROP_CONTEXT) {
			path = separator;
		} else {
			path = contextPath;
		}
		String query = null;
		String fragment = null;

		// Build URI:
		try {
			return new URI(scheme, userInfo, host, port, path, query, fragment);
		} catch (URISyntaxException e) {
			throw new AppException("Error building URL: scheme=" + scheme
					+ ", userInfo=" + userInfo + ", host=" + host + ", port="
					+ port + ", path=" + path + ", query=" + query
					+ ", fragment=" + fragment, e);
		}
	}

	/**
	 * Ensures this path has a leading slash.
	 * 
	 * @param path
	 *            The path.
	 * @return Either the given path, or {@value #separator}+path.
	 */
	private String leadingSlash(String path) {
		String result;
		if (path.startsWith(separator)) {
			result = path;
		} else {
			result = separator + path;
		}
		return result;
	}
}
